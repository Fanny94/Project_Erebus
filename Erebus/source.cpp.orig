#include <iostream>
#include "Gear.h"
#include "Inputs.h"
#include "Assets.h"
#include "ModelAsset.h"
#include "TextureAsset.h"
#include "Window.h"
#include <ctime>
#include "Player.h"
#include "Transform.h"
=======
#include "PerformanceCounter.h"
#include "Particles.h"
#include "Player.h"
>>>>>>> b70f50ddecf681c85489e57045ffff160976ac23

void calculateDt(float& dt, const clock_t& start, const clock_t& end, const int& ticks);
void allocateTransforms(int n);

Window *window = new Window();
Transform* allTransforms;
Gear::GearEngine *engine = new Gear::GearEngine();


int main()
{
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
	
	//Importer::ModelAsset molebat;
	//molebat.load( "Models/mesh.mtf" );
	Importer::Assets assets;
	Importer::ModelAsset* molebat = assets.load<Importer::ModelAsset>( "Models/moleRat.mtf" );
	Importer::TextureAsset* redTexture = assets.load<Importer::TextureAsset>( "Textures/molerat_texturemap2.png" );
	Importer::TextureAsset* greenTexture = assets.load<Importer::TextureAsset>( "Textures/green.dds" );

<<<<<<< HEAD
	float skyboxScale = 1800;
	Gear::Model skybox;
=======
	redTexture->bind();

	/*Gear::Model skybox;
>>>>>>> b0875c71bffaf399c3444bf79bb7dbd7d7913fff
	skybox.setModelAsset(&skyboxAsset);
	skybox.worldMatrix[0][0] = skyboxScale;
	skybox.worldMatrix[1][1] = skyboxScale;
	skybox.worldMatrix[2][2] = skyboxScale;
	skybox.worldMatrix[3][3] = 1;

	skybox.worldMatrix[3][1] = 3;*/

<<<<<<< HEAD
	allocateTransforms(2);
	Model model;
	model.setModelAsset(molebat, engine->renderQueue.modelAdded(&model));
	model.setModelAsset(molebat, engine->renderQueue.modelAdded(&model));
=======
	Gear::Model model;
	model.setModelAsset( molebat );
	model.worldMatrix[0][0] = 1;
	model.worldMatrix[1][1] = 1;
	model.worldMatrix[2][2] = 1;
	model.worldMatrix[3][3] = 1;

	model.worldMatrix[3][0] = 3;

	Gear::Model model2;
	model2.setModelAsset( molebat );
	model2.worldMatrix[0][0] = 1;
	model2.worldMatrix[1][1] = 1;
	model2.worldMatrix[2][2] = 1;
	model2.worldMatrix[3][3] = 1;

	model2.worldMatrix[3][0] = -3;
	
	Gear::Particle particle;
	glm::vec3 pos;
	glm::vec3 color;


	Player player;
	Gear::Model playerModel;
	playerModel.setModelAsset(&molebat);


	player.model = &playerModel;



	player.model = &playerModel;


>>>>>>> b70f50ddecf681c85489e57045ffff160976ac23

	// TEMP: Ritar ut modellen från Gear.
<<<<<<< HEAD
	engine->renderElements.push_back(&skybox);
	engine->renderElements.push_back(player.model);
=======
	//engine->renderElements.push_back(&skybox);
	engine->renderElements.push_back(player.model);


	for (int i = 0; i < particle.getParticleCount(); i++)
	{
		pos = {rand() % 10, rand() % 5, rand() % 10 };
		color = {1.0, 0.0, 0.0};

		particle.setParticle(pos, color, i);

<<<<<<< HEAD
=======
		particle.getParticle();

		engine->renderElements.push_back(&particle);

	}

>>>>>>> b70f50ddecf681c85489e57045ffff160976ac23
	glEnable( GL_DEPTH_TEST );
	
	GLFWwindow* w = window->getGlfwWindow();
	Inputs inputs(w);
	clock_t c_start, c_end;
	float dt = 0;
	int totalTicks = 0;
	float totalTime = 0;
<<<<<<< HEAD
	totalTicks++;	
=======
	totalTicks++;
	
	PerformanceCounter counter;
	double frameTime = 0.0;
	int frameCounter = 0;
>>>>>>> b70f50ddecf681c85489e57045ffff160976ac23

	Camera camera(45.f, 1280.f/720.f, 0.1f, 2000.f, &inputs);
	//glm::vec3 point = {0,0,5};
	glm::vec3 direction = {0,0,-1};

	float horizAngle = 3.14f;
	float vertAngle = 0;
	float speed = 8.f;

	bool freeCam = false;

	bool running = true;
	glm::vec3 point = {0,0,0};
	while (running && window->isWindowOpen()){
		c_start = clock();
		inputs.update();
		player.update(&inputs, dt);
		player.update(&inputs, dt);
		skybox.worldMatrix[3][0] = camera.getPosition().x;
		skybox.worldMatrix[3][1] = camera.getPosition().y- skyboxScale/2;
		skybox.worldMatrix[3][2] = camera.getPosition().z;
		camera.follow(player.position, player.lookAt, abs(inputs.getScroll())+5);
		//camera.camUpdate(point, direction, dt);
=======
		/*skybox.worldMatrix[3][0] = camera.getPosition().x;
		skybox.worldMatrix[3][1] = camera.getPosition().y- skyboxScale/2;
		skybox.worldMatrix[3][2] = camera.getPosition().z;*/
<<<<<<< HEAD
		//camera.follow(point, glm::vec3(sinf(1/*angle*/), 0, cosf(1/*angle*/)), abs(inputs.getScroll()));
		camera.camUpdate(point, direction, dt);
		
		float* transforms = new float[6];
		for (int i = 0; i < 2; i++) {
			transforms[i * 3] = allTransforms[i].getPos().x + i;
			transforms[i * 3 + 1] = allTransforms[i].getPos().y + i;
			transforms[i * 3 + 2] = allTransforms[i].getPos().z + i;
		}
		engine->renderQueue.update(transforms, nullptr, 2);
		delete[] transforms;
		
=======
		camera.follow(player.position, player.lookAt, abs(inputs.getScroll())+5);
		//camera.camUpdate(point, direction, dt);
>>>>>>> b70f50ddecf681c85489e57045ffff160976ac23
		engine->draw(&camera);
		window->update();
		c_end = clock();
		calculateDt(dt, c_start, c_end, totalTicks);

		frameCounter++;
		frameTime += counter.getDeltaTime();
		if (frameTime >= 1000.0)
		{
			double fps = double(frameCounter) / (frameTime / 1000.0);

			std::cout << "FPS: " << fps << std::endl;

			frameTime -= 1000.0;
			frameCounter = 0;
		}

		if( inputs.keyPressed( GLFW_KEY_ESCAPE ) )
			running = false;
		if( inputs.keyPressedThisFrame( GLFW_KEY_1 ) )
			redTexture->bind();
		else if( inputs.keyPressedThisFrame( GLFW_KEY_2 ) )
			greenTexture->bind();
	}
	delete[] allTransforms;
	delete window;
	glfwTerminate();
	delete engine;
	return 0;
}

void calculateDt(float& dt, const clock_t& start, const clock_t& end, const int& ticks) 
{	
	dt = ((float)end - (float)start) / CLOCKS_PER_SEC;
	//std::cout << dt << std::endl;
}

void allocateTransforms(int n)
{
	allTransforms = new Transform[n];
	engine->renderQueue.allocateWorlds(n);
}

#include <iostream>
#include "Nurn.hpp"
#include "Gear.h"
#include "Inputs.h"
#include "Assets.h"
#include "ModelAsset.h"
#include "TextureAsset.h"
#include "Window.h"
#include <ctime>
#include "Transform.h"
#include "PerformanceCounter.h"
#include "ParticleSystem.h"
#include "SphereCollider.h"
#include "AABBCollider.h"
#include "CollisionHandler.h"
#include "Controls.h"
#include <lua\lua.hpp>
#include "LuaBinds.h"
#include <String>
#include <thread>
#include "HeightMap.h"
#include "Ray.h"

int startNetworkCommunication( Window* window );
int startNetworkSending(Nurn::NurnEngine * pSocket, Window* window);
int startNetworkReceiving(Nurn::NurnEngine * pSocket, Window* window);

std::thread networkThread;
bool networkActive = false;
bool networkHost = true;

bool running = true;

<<<<<<< HEAD
=======
std::vector<ModelInstance> models;

>>>>>>> 035234ddc0900848edc765637d85dfa624764bff
int main()
{
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
	
	Importer::Assets assets;

	int nrOfTransforms = 100;
	int boundTransforms = 0;
	Transform* transforms = new Transform[nrOfTransforms];
	Controls controls;

	Window window;
	Gear::GearEngine engine;
	engine.renderQueue.allocateWorlds(nrOfTransforms);

	std::vector<ModelInstance> models;

<<<<<<< HEAD
	double deltaTime = 0.0;

	Importer::TextureAsset* moleratTexture = assets.load<Importer::TextureAsset>( "Textures/molerat_texturemap2.png" );
	moleratTexture->bind();

	CollisionHandler collisionHandler;
	collisionHandler.setTransforms( transforms );
	
	//controls.setControl(&transforms[1]);

=======

	Gear::ParticleSystem* ps = new Gear::ParticleSystem();
	//engine->renderQueue.particleSystem.push_back(ps);
 	
>>>>>>> 035234ddc0900848edc765637d85dfa624764bff
	glEnable( GL_DEPTH_TEST );
	
	GLFWwindow* w = window.getGlfwWindow();
	Inputs inputs(w);

	PerformanceCounter counter;
	counter.startCounter();
	double frameTime = 0.0;
	int frameCounter = 0;

	Camera camera(45.f, 1280.f/720.f, 0.1f, 2000.f, &inputs);

<<<<<<< HEAD
	float* transformData = new float[6 * nrOfTransforms];
=======
	float* transforms = new float[9 * nrOfTransforms];
>>>>>>> 035234ddc0900848edc765637d85dfa624764bff
	glm::vec3* lookAts = new glm::vec3[nrOfTransforms];
	engine->bindTransforms(transforms, nullptr, &boundTrans, lookAts);

	if (networkActive)
	{
		networkThread = std::thread(startNetworkCommunication, &window );
	}

	LuaBinds luaBinds;
	luaBinds.load( &engine, &assets, &collisionHandler, &controls, transforms, &boundTransforms, &models );

	bool playerAlive = true;
	while (running && window.isWindowOpen())
	{
<<<<<<< HEAD
		deltaTime = counter.getDeltaTime();
		inputs.update();

		controls.update( &inputs );

		luaBinds.update( &controls, deltaTime );

		camera.follow(controls.getControl()->getPos(), controls.getControl()->getLookAt(), abs(inputs.getScroll())+5.f);

		for (int i = 0; i < boundTransforms; i++) 
		{
			int index = i * 6;
			glm::vec3 pos = transforms[i].getPos();
			glm::vec3 rot = transforms[i].getRotation();
			transformData[index] = pos.x;
			transformData[index + 1] = pos.y;
			transformData[index + 2] = pos.z;
			transformData[index + 3] = rot.x;
			transformData[index + 4] = rot.y;
			transformData[index + 5] = rot.z;
		}

		for (int i = 0; i < boundTransforms; i++)
		{
			lookAts[i] = transforms[i].getLookAt();
		}
		engine.renderQueue.update(transformData, nullptr, boundTransforms, lookAts);
		engine.draw(&camera, &models);
		window.update();	

		if( inputs.keyPressed( GLFW_KEY_ESCAPE ) )
			running = false;

=======

		deltaTime = counter.getDeltaTime();
		inputs.update();

		if( playerAlive )
			controls.sendControls(inputs, L);

		/*for (size_t i = 0; i < engine->renderQueue.particleSystem.size(); i++)
		{
			for (size_t j = 0; j < 10; j++)
			{
				ps[i].particles[j]->update(glm::vec3(0, 0, 0.005));
			}
		}*/

		lua_getglobal(L, "updateBullets");
		lua_pushnumber(L, deltaTime);
		if (lua_pcall(L, 1, 0, 0))
			std::cout << lua_tostring(L, -1) << std::endl;
		//lua_pop(L, 1);
		 

		camera.follow(controls.getControl()->getPos(), controls.getControl()->getLookAt(), abs(inputs.getScroll())+5.f);
	
		if( playerAlive )
		{	
			lua_getglobal( L, "Update" );
			lua_pushnumber( L, deltaTime );
			if( lua_pcall( L, 1, 1, 0 ) )
				std::cout << lua_tostring( L, -1 ) << std::endl;
			playerAlive = lua_toboolean( L, -1 );	
			lua_pop(L,1);
		}
		else
			std::cout << "Game Over" << std::endl;
			
		//Update transforms:
		int index = 0;
		for (int i = 0; i < nrOfTransforms; i++) 
		{
			if (!availableTransforms[i]) {

				glm::vec3 pos = allTransforms[i].getPos();
				glm::vec3 rot = allTransforms[i].getRotation();
				glm::vec3 scale = allTransforms[i].getScale();
				transforms[index*9] = pos.x;
				transforms[index*9 + 1] = pos.y;
				transforms[index*9 + 2] = pos.z;
				transforms[index*9 + 3] = rot.x;
				transforms[index*9 + 4] = rot.y;
				transforms[index*9 + 5] = rot.z;
				transforms[index*9 + 6] = scale.x;
				transforms[index*9 + 7] = scale.y;
				transforms[index*9 + 8] = scale.z;

				lookAts[index] = allTransforms[i].getLookAt();

				index++;
			}
			
		}
		//std::cout << index << std::endl;

		//Draw:
		engine->queueDynamicModels(&models);
		engine->draw(&camera);
		window->update();	

		if( inputs.keyPressed( GLFW_KEY_ESCAPE ) )
			running = false;
		if( inputs.keyPressedThisFrame( GLFW_KEY_1 ) )
			redTexture->bind();
		else if( inputs.keyPressedThisFrame( GLFW_KEY_2 ) )
			greenTexture->bind();
		//std::cout << lua_gettop(L) << std::endl;
>>>>>>> 035234ddc0900848edc765637d85dfa624764bff
		//Display FPS:
		frameCounter++;
		frameTime += deltaTime;
		if (frameTime >= 1.0)
		{
			double fps = double(frameCounter) / frameTime;
			std::cout << "FPS: " << fps << std::endl;
			frameTime -= 1.0;
			frameCounter = 0;
		}

		//Collisions
		//collisionHandler.checkCollisions();
	}

	luaBinds.unload();

	delete[] transforms;
	delete[] transformData;
	delete[] lookAts;

	if (networkActive)
	{
		networkThread.join();
	}

<<<<<<< HEAD
=======
	delete[] availableTransforms;
	delete[] allTransforms;
	lua_close(L);
	delete window;
	delete ps;
>>>>>>> 035234ddc0900848edc765637d85dfa624764bff
	glfwTerminate();
	return 0;
}

<<<<<<< HEAD
int startNetworkCommunication( Window* window )
=======

int addModelInstance(ModelAsset* asset)
{

	//int result = engine->renderQueue.generateWorldMatrix();
	int result = engine->generateWorldMatrix();

	int index = -1;
	for (int i = 0; i < models.size() && index < 0; i++)
		if (models[i].asset == asset)
			index = i;

	if (index < 0)
	{
		ModelInstance instance;
		instance.asset = asset;

		index = models.size();
		models.push_back(instance);
	}

	models[index].worldIndices.push_back(result);


	return result;
}

void allocateTransforms(int n)
{
	if (allTransforms != nullptr) {
		delete allTransforms;
		delete availableTransforms;
	}
	availableTransforms = new bool[n];
	allTransforms = new Transform[n];
	for (int i = 0; i < n; i++) {
		availableTransforms[i] = true;
	//engine->renderQueue.allocateWorlds(n);
	engine->allocateWorlds(n);
	}
}


int startNetworkCommunication()
>>>>>>> 035234ddc0900848edc765637d85dfa624764bff
{
	// initialize socket layer

	Nurn::NurnEngine network;

	if (!network.Initialize(127, 0, 0, 1))
	{
		printf("failed to initialize sockets\n");
		return 1;
	}

	if (networkHost)
	{
		startNetworkReceiving(&network, window);
	}
	else
	{
		startNetworkSending(&network, window);
	}

	printf("Closing socket on port\n");
	network.Shutdown();

	return 0;
}

int startNetworkSending(Nurn::NurnEngine * pNetwork, Window* window)
{
	while (running && window->isWindowOpen())
	{
		const char data[] = "hello world!";

		pNetwork->Send(data, sizeof(data));

		Sleep(250);
	}

	return 0;
}

int startNetworkReceiving(Nurn::NurnEngine * pNetwork, Window* window)
{
	while (running && window->isWindowOpen())
	{
		printf("Recieving package\n");
		Sleep(250);
		Nurn::Address sender;
		unsigned char buffer[256];
		int bytes_read = pNetwork->Receive(sender, buffer, sizeof(buffer));
		if (bytes_read)
		{
			printf("received packet from %d.%d.%d.%d:%d (%d bytes)\n",
				sender.GetA(), sender.GetB(), sender.GetC(), sender.GetD(),
				sender.GetPort(), bytes_read);
			std::cout << buffer << std::endl;
		}
	}

	return 0;
}